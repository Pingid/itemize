use proc_macro::TokenStream;
use quote::quote;
use syn::{DeriveInput, parse_macro_input};

mod context;
mod from_collections;
mod from_tuples;
mod from_types;

use context::Context;
use from_collections::from_collections;
use from_tuples::from_tuples;
use from_types::from_type;

///
/// # Example
/// ```ignore
/// #[derive(IntoItems)]
/// #[into_items(from_types = [&str, String, i32, f64], from_tuples = 2)]
/// pub struct MySimpleType(String);
/// ```
///
pub fn handle_derive_into_items(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    
    // Validate that this is being used on a struct or enum
    match &ast.data {
        syn::Data::Struct(_) | syn::Data::Enum(_) => {},
        syn::Data::Union(_) => {
            return syn::Error::new_spanned(
                &ast.ident,
                "IntoItems cannot be derived for unions"
            )
            .to_compile_error()
            .into();
        }
    }
    
    let context = match Context::try_new(&ast) {
        Ok(ctx) => ctx,
        Err(e) => return e.to_compile_error().into(),
    };

    let into_items_trait = &context.trait_ident;
    let ident = &context.ident;
    let impl_generics = &context.impl_generics;
    let ty_generics = &context.ty_generics;
    let vis = &context.vis;

    let tuple_impls = from_tuples(&context);
    let from_type_impls = from_type(&context);
    let from_collections_impls = from_collections(&context);

    // Build documentation based on what's being generated
    let mut doc_parts = vec![
        format!("Trait for converting various types into iterators of `{}`.", ident),
        String::from("\nThis trait is automatically generated by `#[derive(IntoItems)]`."),
    ];
    
    if !context.attributes.from_types.is_empty() {
        doc_parts.push(format!(
            "\n\n# Supported single value conversions\n\
             The following types can be converted: `{}`",
            context.attributes.from_types.iter()
                .map(|t| quote!(#t).to_string())
                .collect::<Vec<_>>()
                .join("`, `")
        ));
    }
    
    if let Some(max) = context.attributes.from_tuples {
        doc_parts.push(format!(
            "\n\n# Supported tuple conversions\n\
             Tuples up to {} elements are supported.",
            max
        ));
    }
    
    if !context.attributes.from_collections.is_empty() {
        doc_parts.push(String::from(
            "\n\n# Supported collection conversions\n\
             Collections like `Vec`, slices, and arrays are supported."
        ));
    }

    let doc = doc_parts.join("");

    // Expanded code with documentation and visibility
    let expanded = quote! {
        #[doc = #doc]
        #vis trait #into_items_trait #impl_generics {
            /// The iterator type returned by `into_items()`
            type IntoIter: ::std::iter::Iterator<Item = #ident #ty_generics>;
            
            /// Convert this value into an iterator of items
            fn into_items(self) -> Self::IntoIter;
        }

        #from_type_impls

        #tuple_impls

        #from_collections_impls
    };

    TokenStream::from(expanded)
}
