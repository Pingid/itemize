fn main() {
    let max_tuple_size = std::env::var("INTO_VEC_MAX_TUPLE_SIZE")
        .ok()
        .and_then(|s| s.parse::<usize>().ok())
        .unwrap_or(4);

    let message = vec![
        "// This file is auto-generated by build.rs. Do not edit manually.".to_string(),
        format!("// Generates implementations for tuples up to arity {max_tuple_size}."),
        "// To change this, set the INTO_VEC_MAX_TUPLE_SIZE environment variable before building."
            .to_string(),
    ]
    .join("\n");

    // IntoItems
    write_generated_file(
        "src/into_items/tuples.rs",
        &message,
        &["use crate::{IntoItems, TryIntoItems};"],
        into_items(max_tuple_size),
    );

    // IntoRows
    write_generated_file(
        "src/into_rows/tuples.rs",
        &message,
        &["use crate::{IntoItems, IntoRows, TryIntoItems, TryIntoRows};"],
        into_rows(max_tuple_size),
    );

    // IntoVariadicRows
    write_generated_file(
        "src/into_rows/variadic/tuples.rs",
        &message,
        &[
            "use super::{either::Either, IntoVariadicRows, TryIntoVariadicRows};",
            "use crate::{IntoItems, TryIntoItems};",
        ],
        into_variadic_rows(max_tuple_size),
    );

    std::process::Command::new("cargo")
        .arg("fmt")
        .output()
        .unwrap();
}

fn into_items(max: usize) -> String {
    let mut code = String::new();
    for arity in 2..=max {
        let spec = TupleSpec::new(arity);
        code.push_str(&render_into_items(&spec, IntoItemsTuple::Owned));
        code.push_str(&render_into_items(
            &spec,
            IntoItemsTuple::Ref { lifetime: "'a" },
        ));
        code.push_str(&render_into_items(
            &spec,
            IntoItemsTuple::RefRef {
                outer: "'a",
                inner: "'b",
            },
        ));
    }
    code
}

fn into_rows(max: usize) -> String {
    let mut code = String::new();
    for arity in 2..=max {
        let spec = TupleSpec::new(arity);
        code.push_str(&render_row_impl(&spec, RowBorrow::Owned));
        code.push_str(&render_row_impl(&spec, RowBorrow::Ref { lifetime: "'a" }));
    }
    code
}

fn into_variadic_rows(max: usize) -> String {
    (2..=max)
        .map(generate_hetero_impl_for_n)
        .collect::<String>()
}

fn generate_hetero_impl_for_n(n: usize) -> String {
    let type_params: Vec<String> = (0..n).map(|i| format!("A{i}")).collect();
    let destructure_vars = lowercase_names(&type_params);
    let destructure = destructure_vars.join(", ");

    let array_elements = (0..n)
        .map(|index| {
            let value = format!("{}.into_items()", destructure_vars[index]);
            build_nested_either_value(index, n, &value)
        })
        .collect::<Vec<_>>();
    let array_lines = array_elements
        .iter()
        .map(|value| format!("{value},"))
        .collect::<Vec<_>>();

    let try_array_elements = (0..n)
        .map(|index| {
            let value = format!("{}.try_into_items()", destructure_vars[index]);
            build_nested_either_value(index, n, &value)
        })
        .collect::<Vec<_>>();
    let try_array_lines = try_array_elements
        .iter()
        .map(|value| format!("{value},"))
        .collect::<Vec<_>>();

    let mut owned_generics = Vec::with_capacity(n + 1);
    owned_generics.push("T".to_string());
    owned_generics.extend(type_params.iter().cloned());
    let owned_constraints = type_params
        .iter()
        .map(|param| format!("{param}: IntoItems<T>,"))
        .collect::<Vec<_>>();
    let owned_impl = render_hetero_impl(
        owned_generics.clone(),
        format!("({})", type_params.join(", ")),
        owned_constraints.clone(),
        build_nested_either_type_generic(&type_params),
        &destructure,
        array_lines.clone(),
        n,
        false,
    );

    let mut owned_try_generics = Vec::with_capacity(n + 2);
    owned_try_generics.push("T".to_string());
    owned_try_generics.push("E".to_string());
    owned_try_generics.extend(type_params.iter().cloned());
    let owned_try_constraints = type_params
        .iter()
        .map(|param| format!("{param}: TryIntoItems<T, E>,"))
        .collect::<Vec<_>>();
    let owned_try_impl = render_hetero_impl(
        owned_try_generics,
        format!("({})", type_params.join(", ")),
        owned_try_constraints,
        build_nested_either_type_try_generic(&type_params),
        &destructure,
        try_array_lines.clone(),
        n,
        true,
    );

    let mut borrowed_generics = Vec::with_capacity(n + 2);
    borrowed_generics.push("'a".to_string());
    borrowed_generics.push("T".to_string());
    borrowed_generics.extend(type_params.iter().cloned());
    let borrowed_constraints = type_params
        .iter()
        .map(|param| format!("&'a {param}: IntoItems<T>,"))
        .collect::<Vec<_>>();
    let borrowed_impl = render_hetero_impl(
        borrowed_generics.clone(),
        format!("&'a ({})", type_params.join(", ")),
        borrowed_constraints.clone(),
        build_nested_either_type_generic_borrowed(&type_params),
        &destructure,
        array_lines,
        n,
        false,
    );

    let mut borrowed_try_generics = Vec::with_capacity(n + 3);
    borrowed_try_generics.push("'a".to_string());
    borrowed_try_generics.push("T".to_string());
    borrowed_try_generics.push("E".to_string());
    borrowed_try_generics.extend(type_params.iter().cloned());
    let borrowed_try_constraints = type_params
        .iter()
        .map(|param| format!("&'a {param}: TryIntoItems<T, E>,"))
        .collect::<Vec<_>>();
    let borrowed_try_impl = render_hetero_impl(
        borrowed_try_generics,
        format!("&'a ({})", type_params.join(", ")),
        borrowed_try_constraints,
        build_nested_either_type_try_generic_borrowed(&type_params),
        &destructure,
        try_array_lines,
        n,
        true,
    );

    owned_impl + &owned_try_impl + &borrowed_impl + &borrowed_try_impl
}

fn lowercase_names(names: &[String]) -> Vec<String> {
    names.iter().map(|name| name.to_lowercase()).collect()
}

enum IntoItemsTuple {
    Owned,
    Ref {
        lifetime: &'static str,
    },
    RefRef {
        outer: &'static str,
        inner: &'static str,
    },
}

impl IntoItemsTuple {
    fn generics(&self) -> Vec<String> {
        match self {
            Self::Owned => Vec::new(),
            Self::Ref { lifetime } => vec![lifetime.to_string()],
            Self::RefRef { outer, inner } => vec![outer.to_string(), inner.to_string()],
        }
    }

    fn tuple_ty(&self, spec: &TupleSpec) -> String {
        let args = spec.join_types(", ");
        match self {
            Self::Owned => format!("({args})"),
            Self::Ref { lifetime } => format!("&{lifetime} ({args})"),
            Self::RefRef { outer, inner } => format!("&{outer} &{inner} ({args})"),
        }
    }

    fn iter_type(&self, spec: &TupleSpec) -> String {
        match self {
            Self::Owned | Self::Ref { .. } => {
                format!("std::array::IntoIter<T, {}>", spec.arity())
            }
            Self::RefRef { inner, .. } => format!(
                "<&{inner} ({}) as IntoItems<T>>::IntoIter",
                spec.join_types(", ")
            ),
        }
    }

    fn constraints(&self, spec: &TupleSpec) -> Vec<String> {
        match self {
            Self::Owned => spec.map_types(|ty| format!("T: From<{ty}>,")),
            Self::Ref { lifetime } => spec.map_types(|ty| format!("T: From<&{lifetime} {ty}>,")),
            Self::RefRef { outer, inner } => {
                let mut lines = vec![format!("{outer}: {inner},")];
                lines.extend(spec.map_types(|ty| format!("T: From<&{inner} {ty}>,")));
                lines
            }
        }
    }

    fn body(&self, spec: &TupleSpec) -> Vec<String> {
        match self {
            Self::Owned | Self::Ref { .. } => vec![
                format!("let ({}) = self;", spec.join_values(", ")),
                format!(
                    "[{}].into_iter()",
                    spec.map_values(|value| format!("T::from({value})"))
                        .join(", ")
                ),
            ],
            Self::RefRef { .. } => vec!["(*self).into_items()".to_string()],
        }
    }

    fn try_iter_type(&self, spec: &TupleSpec) -> String {
        match self {
            Self::Owned | Self::Ref { .. } => {
                format!("std::array::IntoIter<Result<T, E>, {}>", spec.arity())
            }
            Self::RefRef { inner, .. } => format!(
                "<&{inner} ({}) as TryIntoItems<T, E>>::IntoIter",
                spec.join_types(", ")
            ),
        }
    }

    fn try_constraints(&self, spec: &TupleSpec) -> Vec<String> {
        match self {
            Self::Owned => spec.map_types(|ty| format!("T: TryFrom<{ty}, Error = E>,")),
            Self::Ref { lifetime } => {
                spec.map_types(|ty| format!("T: TryFrom<&{lifetime} {ty}, Error = E>,"))
            }
            Self::RefRef { outer, inner } => {
                let mut lines = vec![format!("{outer}: {inner},")];
                lines.extend(spec.map_types(|ty| format!("T: TryFrom<&{inner} {ty}, Error = E>,")));
                lines
            }
        }
    }

    fn try_body(&self, spec: &TupleSpec) -> Vec<String> {
        match self {
            Self::Owned | Self::Ref { .. } => vec![
                format!("let ({}) = self;", spec.join_values(", ")),
                format!(
                    "[{}].into_iter()",
                    spec.map_values(|value| format!("T::try_from({value})"))
                        .join(", ")
                ),
            ],
            Self::RefRef { .. } => vec!["(*self).try_into_items()".to_string()],
        }
    }
}

enum RowBorrow {
    Owned,
    Ref { lifetime: &'static str },
}

impl RowBorrow {
    fn generics(&self) -> Vec<String> {
        match self {
            RowBorrow::Owned => Vec::new(),
            RowBorrow::Ref { lifetime } => vec![lifetime.to_string()],
        }
    }

    fn tuple_ty(&self, spec: &TupleSpec) -> String {
        let args = spec.join_types(", ");
        match self {
            RowBorrow::Owned => format!("({args})"),
            RowBorrow::Ref { lifetime } => format!("&{lifetime} ({args})"),
        }
    }

    fn iter_binding(&self, spec: &TupleSpec) -> String {
        match self {
            RowBorrow::Owned => format!("<{} as IntoItems<T>>::IntoIter", spec.first_type()),
            RowBorrow::Ref { lifetime } => format!(
                "<&{lifetime} {} as IntoItems<T>>::IntoIter",
                spec.first_type()
            ),
        }
    }

    fn constraints(&self, spec: &TupleSpec, iter_binding: &str) -> Vec<String> {
        match self {
            RowBorrow::Owned => {
                let mut lines = Vec::with_capacity(spec.arity());
                lines.push(format!("{}: IntoItems<T>,", spec.first_type()));
                lines.extend(
                    spec.types()
                        .iter()
                        .skip(1)
                        .map(|ty| format!("{ty}: IntoItems<T, IntoIter = {iter_binding}>,")),
                );
                lines
            }
            RowBorrow::Ref { lifetime } => {
                let mut lines = Vec::with_capacity(spec.arity());
                lines.push(format!("&{lifetime} {}: IntoItems<T>,", spec.first_type()));
                lines.extend(spec.types().iter().skip(1).map(|ty| {
                    format!("&{lifetime} {ty}: IntoItems<T, IntoIter = {iter_binding}>,")
                }));
                lines
            }
        }
    }

    fn try_iter_binding(&self, spec: &TupleSpec) -> String {
        match self {
            RowBorrow::Owned => {
                format!("<{} as TryIntoItems<T, E>>::IntoIter", spec.first_type())
            }
            RowBorrow::Ref { lifetime } => format!(
                "<&{lifetime} {} as TryIntoItems<T, E>>::IntoIter",
                spec.first_type()
            ),
        }
    }

    fn try_constraints(&self, spec: &TupleSpec, iter_binding: &str) -> Vec<String> {
        match self {
            RowBorrow::Owned => {
                let mut lines = Vec::with_capacity(spec.arity());
                lines.push(format!("{}: TryIntoItems<T, E>,", spec.first_type()));
                lines.extend(
                    spec.types()
                        .iter()
                        .skip(1)
                        .map(|ty| format!("{ty}: TryIntoItems<T, E, IntoIter = {iter_binding}>,")),
                );
                lines
            }
            RowBorrow::Ref { lifetime } => {
                let mut lines = Vec::with_capacity(spec.arity());
                lines.push(format!(
                    "&{lifetime} {}: TryIntoItems<T, E>,",
                    spec.first_type()
                ));
                lines.extend(spec.types().iter().skip(1).map(|ty| {
                    format!("&{lifetime} {ty}: TryIntoItems<T, E, IntoIter = {iter_binding}>,")
                }));
                lines
            }
        }
    }
}

fn render_into_items(spec: &TupleSpec, borrow: IntoItemsTuple) -> String {
    let mut generics = borrow.generics();
    generics.push("T".to_string());
    generics.extend(spec.types().iter().cloned());
    let generics = format!("<{}>", generics.join(", "));

    let mut try_generics = borrow.generics();
    try_generics.push("T".to_string());
    try_generics.push("E".to_string());
    try_generics.extend(spec.types().iter().cloned());
    let try_generics = format!("<{}>", try_generics.join(", "));

    let tuple_ty = borrow.tuple_ty(spec);
    let iter_type = borrow.iter_type(spec);
    let constraints = indent_block(&borrow.constraints(spec), 4);

    let try_iter_type = borrow.try_iter_type(spec);
    let try_constraints = indent_block(&borrow.try_constraints(spec), 4);

    let body_lines = borrow.body(spec);
    let body = indent_block(&body_lines, 8);

    let try_body_lines = borrow.try_body(spec);
    let try_body = indent_block(&try_body_lines, 8);

    format!(
        r#" 
        impl{generics} IntoItems<T> for {tuple_ty}
        where {constraints}
        {{
            type IntoIter = {iter_type};
            fn into_items(self) -> Self::IntoIter {{
                {body}
            }}
        }}

        impl{try_generics} TryIntoItems<T, E> for {tuple_ty}
        where
        {try_constraints}
        {{
            type IntoIter = {try_iter_type};
            fn try_into_items(self) -> Self::IntoIter {{
                {try_body}
            }}
        }}
        "#
    )
}

fn render_row_impl(spec: &TupleSpec, borrow: RowBorrow) -> String {
    let mut generics = borrow.generics();
    generics.push("T".to_string());
    generics.extend(spec.types().iter().cloned());
    let generics = format!("<{}>", generics.join(", "));

    let mut try_generics = borrow.generics();
    try_generics.push("T".to_string());
    try_generics.push("E".to_string());
    try_generics.extend(spec.types().iter().cloned());
    let try_generics = format!("<{}>", try_generics.join(", "));

    let tuple_ty = borrow.tuple_ty(spec);
    let iter_binding = borrow.iter_binding(spec);
    let constraints = indent_block(&borrow.constraints(spec, &iter_binding), 4);
    let body = indent_block(
        &[
            format!("let ({}) = self;", spec.join_values(", ")),
            format!(
                "[{}].into_iter()",
                spec.map_values(|value| format!("{value}.into_items()"))
                    .join(", ")
            ),
        ],
        8,
    );

    let try_iter_binding = borrow.try_iter_binding(spec);
    let try_constraints = indent_block(&borrow.try_constraints(spec, &try_iter_binding), 4);
    let try_body = indent_block(
        &[
            format!("let ({}) = self;", spec.join_values(", ")),
            format!(
                "[{}].into_iter()",
                spec.map_values(|value| format!("{value}.try_into_items()"))
                    .join(", ")
            ),
        ],
        8,
    );

    format!(
        r#"
        impl{generics} IntoRows<T> for {tuple_ty}
        where {constraints}
        {{
            type RowIter = {iter_binding};
            type Rows = std::array::IntoIter<Self::RowIter, {}>;
            fn into_rows(self) -> Self::Rows {{
                {body}
            }}
        }}

        impl{try_generics} TryIntoRows<T, E> for {tuple_ty}
        where {try_constraints}
        {{
            type RowIter = {try_iter_binding};
            type Rows = std::array::IntoIter<Self::RowIter, {}>;
            fn try_into_rows(self) -> Self::Rows {{
                {try_body}
            }}
        }}
        "#,
        spec.arity(),
        spec.arity()
    )
}

fn render_hetero_impl(
    generics: Vec<String>,
    tuple_ty: String,
    constraints: Vec<String>,
    row_iter_type: String,
    destructure: &str,
    array_lines: Vec<String>,
    arity: usize,
    is_try: bool,
) -> String {
    let generics = format!("<{}>", generics.join(", "));
    let constraints = indent_block(&constraints, 4);
    let array_block = indent_block(&array_lines, 12);

    if is_try {
        format!(
            r#"
        impl{generics} TryIntoVariadicRows<T, E> for {tuple_ty}
        where
        {constraints}
        {{
            type RowIter = {row_iter_type};
            type Rows = std::array::IntoIter<Self::RowIter, {arity}>;
            fn try_into_variadic_rows(self) -> Self::Rows {{
                let ({destructure}) = self;
                use Either::{{Left, Right}};
                [
                {array_block}
                ].into_iter()
            }}
        }}
        "#
        )
    } else {
        format!(
            r#"
        impl{generics} IntoVariadicRows<T> for {tuple_ty}
        where
        {constraints}
        {{
            type RowIter = {row_iter_type};
            type Rows = std::array::IntoIter<Self::RowIter, {arity}>;
            fn into_variadic_rows(self) -> Self::Rows {{
                let ({destructure}) = self;
                use Either::{{Left, Right}};
                [
                {array_block}
                ].into_iter()
            }}
        }}
        "#
        )
    }
}

fn build_nested_either_type_generic(type_params: &[String]) -> String {
    build_nested_either_type(type_params, &|param| format!("{param}::IntoIter"))
}

fn build_nested_either_type_generic_borrowed(type_params: &[String]) -> String {
    build_nested_either_type(type_params, &|param| {
        format!("<&'a {param} as IntoItems<T>>::IntoIter")
    })
}

fn build_nested_either_type_try_generic(type_params: &[String]) -> String {
    build_nested_either_type(type_params, &|param| format!("{param}::IntoIter"))
}

fn build_nested_either_type_try_generic_borrowed(type_params: &[String]) -> String {
    build_nested_either_type(type_params, &|param| {
        format!("<&'a {param} as TryIntoItems<T, E>>::IntoIter")
    })
}

fn build_nested_either_type<F>(type_params: &[String], formatter: &F) -> String
where
    F: Fn(&str) -> String,
{
    match type_params {
        [] => panic!("Need at least one type"),
        [single] => formatter(single),
        [first, rest @ ..] => {
            let left = formatter(first);
            let right = build_nested_either_type(rest, formatter);
            format!("Either<\n        {left},\n        {right}\n    >")
        }
    }
}

fn build_nested_either_value(index: usize, total: usize, value: &str) -> String {
    if total == 1 {
        return value.to_string();
    }

    if total == 2 {
        return match index {
            0 => format!("Left({value})"),
            _ => format!("Right({value})"),
        };
    }

    if index == 0 {
        return format!("Left({value})");
    }

    let mut result = value.to_string();
    if index < total - 1 {
        result = format!("Left({result})");
    }

    for _ in 0..index {
        result = format!("Right({result})");
    }

    result
}

struct TupleSpec {
    arity: usize,
    types: Vec<String>,
    values: Vec<String>,
}

impl TupleSpec {
    fn new(arity: usize) -> Self {
        let types = (0..arity).map(|index| format!("A{index}")).collect();
        let values = (0..arity).map(|index| format!("a{index}")).collect();
        Self {
            arity,
            types,
            values,
        }
    }

    fn arity(&self) -> usize {
        self.arity
    }

    fn types(&self) -> &[String] {
        &self.types
    }

    fn first_type(&self) -> &str {
        &self.types[0]
    }

    fn join_types(&self, separator: &str) -> String {
        self.types.join(separator)
    }

    fn join_values(&self, separator: &str) -> String {
        self.values.join(separator)
    }

    fn map_types<F>(&self, f: F) -> Vec<String>
    where
        F: Fn(&str) -> String,
    {
        self.types.iter().map(|ty| f(ty)).collect()
    }

    fn map_values<F>(&self, f: F) -> Vec<String>
    where
        F: Fn(&str) -> String,
    {
        self.values.iter().map(|value| f(value)).collect()
    }
}

fn indent_block(lines: &[String], spaces: usize) -> String {
    let indent = " ".repeat(spaces);
    lines
        .iter()
        .map(|line| format!("{indent}{line}"))
        .collect::<Vec<_>>()
        .join("\n")
}

fn write_generated_file(path: &str, message: &str, imports: &[&str], body: String) {
    let mut contents = Vec::new();
    contents.push(message.to_string());
    contents.push(String::new());
    contents.extend(imports.iter().map(|line| (*line).to_string()));
    contents.push(String::new());
    contents.push(body);

    write_file(path, &contents);
}

fn write_file(pth: impl Into<std::path::PathBuf>, contents: &[String]) {
    use std::io::Write;
    let path = pth.into();
    std::fs::create_dir_all(path.parent().unwrap()).unwrap();
    let mut file = std::io::BufWriter::new(std::fs::File::create(&path).unwrap());

    for line in contents {
        writeln!(file, "{}", line).unwrap();
    }
}
